import { OpenAIStream, StreamingTextResponse } from 'ai'
import { Configuration, OpenAIApi } from 'openai-edge'

import generatePalette from '../actions/generatePalette'
import Generator from './generator'
import Results from './results'

export const metadata = {
  title: 'Generate a color palette',
  description: 'Generated by create next app',
}

async function getData(query: string) {
  console.clear()
  // console.info(query)
  // const res = await fetch('https://api.example.com/...')
  // // The return value is *not* serialized
  // // You can return Date, Map, Set, etc.
 
  // // Recommendation: handle errors
  // if (!res.ok) {
  //   // This will activate the closest `error.js` Error Boundary
  //   throw new Error('Failed to fetch data')
  // }

  // In here do the stuff with the OpenAI SDK and grab your palette.
  const request = await fetch('http://localhost:3000/api/palette', {
    method: 'post',
    body: JSON.stringify({
      query,
    })
  })

  return request

  // console.info({ request })

  // return new Promise((resolve) => {
  //   setTimeout(() => {
  //     console.info('loaded data.... brrr')
  //     resolve({
  //       query,
  //     })
  //   }, 2000)
  // })
}
// NOTE:: It would be cool to instead do this over an Edge/Serverless function using something
// like HTML Rewriter instead. Then you wouldn't need client side JavaScript...
export default async function Generate(props: { searchParams?: {
  query?: string
}}) {
  let data: any
  if (props?.searchParams?.query) {
    const submit = new FormData()
    submit.append("query", props?.searchParams?.query)
    data = await (await generatePalette(submit)).json()
  }
  // Grab the searchParams here and if there are some, show the results block which can load in by itself
  // if (props?.searchParams?.query) {
  // }
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <h1>Generate a palette...</h1>
      <Generator />
      {data ? <Results data={data}/> : null}
    </main>
  )
}